# Regex

## Классы и диапазоны
- `'1 abc'.match(/\d\s\w/)` - найдёт '1 a', потому что цифра -> пробел -> 0-9A-z_
- `'1 abc'.match(/[0-9][\t\n\v\f\r ][a-zA-Z0-9_]/)` - то же, что и прошлый пример
- `'ga.asd'.match(/\D\S\W/)` - найдёт 'ga.', потому что не-цифра -> не-пробел -> не 0-9A-z_

## X или Y
- `['1adf', '.adf'].forEach(s => console.log(s.match(/[.1]/)))` - найдёт 1 и ., потому что внутри [] всё сравнивается по ИЛИ

## Исключающий диапазон
- `['.1adf', '.1adf'].forEach(s => console.log(s.match(/[^.1]/)))` - оба раза a, потому что [^.1] ищет не-точку и не 1 (точку можно не экранировать внутри [])

## Опережающие и ретроспективные проверки
- `'1 индейка стоит 30€'.match(/\d+(?=€)/)` - найдёт 30, потому что за цифрой (?=€) следует знак евро
- `'1 индейка стоит 30€'.match(/\d+(?!€)/)` - найдёт 1, потому что за цифрой (?!€) не следует знак евро
- `'1 индейка стоит €30'.match(/(?<=€)\d+/)` - найдёт 30, потому что перед цифрой (?<=€) стоит знак евро
- `'1 индейка стоит €30'.match(/(?<=€)\d+/)` - найдёт 1, потому что перед цифрой (?<!€) не стоит знак евро

## Жадные и ленивые квантификаторы
- `'"witch" and her "broom"'.match(/".+"/)` - найдёт '"witch" and her "broom"' (и потратит кучу шагов), потому что по-дефолту квантификаторы ищут жадно
- `'"witch" and her "broom"'.match(/".+?"/)` - найдёт '"witch"'
- `'"witch" and her "broom"'.match(/"[^"]+"/)` - для такого рода задач лучше использовать этот подход: кавычка, за которой следует больше одной не-кавычки, за которыми следует кавычка

## Группы
- `<span class="my">'.match(/<([a-z]+)\s*/)` - вернёт `['<span ', 'span']` - первый элемент - всё совпадение, второй - найденная группа
- `'<span class="my">'.match(/<(([a-z]+)\s*([^>]*))>/)` - вернёт `['<span class="my">', 'span class="my"', 'span', 'class="my"']` - всё совпадение, общая группа, вложенная группа-1, вложенная группа-2
- `'2019-04-30'.match(/(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})/)` - вернёт result; result.length === 4 (как и в прошлых примерах), result.groups = { day: '30', ... } - с помощью (?<day>.*) мы можем задавать имена группам; NB! В js работает, в остальных языках - хз
- `'2019-04-30'.replace(/(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})/, '$<day>.$<month>.$<year>')` - вернёт '30.04.2019'
- в firefox именованные группы не работают! `'2019-04-30'.replace(/([0-9]{4})-([0-9]{2})-([0-9]{2})/, '$3.$2.$1')` - будет только в таком виде работать
- `"Gogo John!".match(/(?:go)+ (\w+)/i)` - вернёт ['Gogo John', 'John'], потому что с помощью (?: мы исключиили группу из запоминания

## Производительность!
- [Статья про это](https://learn.javascript.ru/regexp-infinite-backtracking-problem)
- вкратце - осторожнее с `(\d+)*$`, `<(\s*\w+=\w+\s*)*>` и другими regex, где после квартификатора (хоть ленивого, хоть жадного) стоит символ. В случаях, когда совпадения никогда не будет ('123124125125z', например, для 1 regex), он может подвесить систему с 100% cpu
